Why do we need scheduling?
A typical process involves both I/O time and CPU time. In a uniprogramming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multiprogramming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.

Objectives of Process Scheduling Algorithm:

Max CPU utilization (Keep CPU as busy as possible)
Fair allocation of CPU.
Max throughput (Number of processes that complete their execution per time unit)
Min turnaround time (Time taken by a process to finish execution)
Min waiting time (Time for which a process waits in ready queue)
Min response time (Time when a process produces first response)
Different Scheduling Algorithms:

First Come First Serve (FCFS) : Simplest scheduling algorithm that schedules according to arrival times of processes.
Shortest Job First (SJF): Process which have the shortest burst time are scheduled first.
Shortest Remaining Time First (SRTF): It is preemptive mode of SJF algorithm in which jobs are scheduled according to the shortest remaining time.
Round Robin (RR) Scheduling: Each process is assigned a fixed time, in cyclic way.
Priority Based scheduling (Non Preemptive): In this scheduling, processes are scheduled according to their priorities, i.e., highest priority process is schedule first. If priorities of two processes match, then scheduling is according to the arrival time.
Highest Response Ratio Next (HRRN): In this scheduling, processes with highest response ratio is scheduled. This algorithm avoids starvation.
Response Ratio = (Waiting Time + Burst time) / Burst time
Multilevel Queue Scheduling (MLQ): According to the priority of process, processes are placed in the different queues. Generally high priority process are placed in the top level queue. Only after completion of processes from top level queue, lower level queued processes are scheduled.
Multi level Feedback Queue (MLFQ) Scheduling: It allows the process to move in between queues. The idea is to separate processes according to the characteristics of their CPU bursts. If a process uses too much CPU time, it is moved to a lower-priority queue.